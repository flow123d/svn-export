version 1.4 cile
----------------

- funkcni testy Test1-3, pro petsc, matlab isol
- funkcni Nschur 0-2
- pocitani transportu pomoci matice
- doxygen dokumentace (read_ini, solver, system)
- aktualni dokumentace vstupu a solveru
- objektovy obal okolo Petsc Matic a Vektoru
- objektove solvery
- zacleneni paralelniho kodu
- funkcni na platformach: linux ia32, ia64; win; hydra
- optimalizovane buildy pro win a linux ia32,ia64
- formatovani zdrojaku ??

TODO version pre1.4
--------------------

INI Reader
- v OptGetStr - testovat, ze read_ini je ne NULL
- v OptGetStr - testovat, ze prvni pointer neni NULL 

- komentare spis '#' , '//' je ceckovske, ani to neni standard v ini, tam jsou komentare ';'
- samostatnou fci strip_spaces()




1) dokonceni sluceni JK a JB vetve:
- !!! je nutne treba predelat cteni v material.c
- output.c mel by se rozdelit k jednotlivym "objektum"
- solve.c write_sys_gm6 - nepouziva zadane parametry solveru !!
- problem.c - subst_names, subst_scales - jednotny pristup k zadavani malych poli retezcu a hodnot
- solve.* -> Solver.* ... podobne promyslet nazvy vsech souboru
- hashes.c - vytvorit abstraktni hash - odstranit zavislost na mesh.c boundaries.h ...
- topology.h - odstranit zavislost na Concentretions.h ...
- elements.c a dalsi - unsteady flow - projit zkontrolovat, testovat
- ZERO - pouzivano v ruznych kontextech, pri vystupu do Matlabu, nebo Isol, se orezava matice !!!
- topology.c 113 osetrit dalsi parametry ??? 
- struct Reaction - kde by to melo byt ???, vypada to na transport material.

Nema cenu zatim resit, dokud se neoddeli koncentrace od elementu (ponechal bych zatim zakomentovane)
  - problem.[hc] projit novy kod ohledne cross section -> zavest nove struktury !!
  - main.c density: terrible functions save_iteration_A, restart_iteration_C ...
  - postprocess.c 1205 BTC,...
  - main.c 146 BTC, CS stuff
  - main.c 188 BTC, CS stuff
  - main.c 259 BTC stuff
  - output.c 76 - CS
  - postprocess.c  1211 - CS
  - ppfcs.c - CS stuff
  - output.c 1572 Clarify BTC, FTRANS, CS code, namely in problem.c, create separate structure and file !!

	
3)
- vytvorit samostatny "modul" water - pridat tam veci z sttruct Problem a use_last_solution ze struct solver
- Solver udelat jako objekt, oddelit ISOL a GM6 parametry (i ve vstupu), oddelit nejak i PETSC parametry,
  sjednotit GM6 solvery pod jeden objekt 
  Vlastne by stacila implementace obecneho externiho solveru a parametry externiho solveru by se nemusely parsovat, bud by uzivatel
  zadal primo control file, nebo by zadal retezec, ktery by se pripojil k vygenerovanemu control file.
  No stejne bych mohl mit objekt ExternalSolver - ktery by mel vitualni potomky GM6 a ISOL a MATLAB
  s prislusnejma metodama pro inicializaci svejch prmennejch a pod. 
  objekt solver by teda primo slouzil jen pro iterface k PETSC solveru a jako alternativu by v sobe mel volani externiho solveru.


- LinSystem rozdelit na matici a vektor , kazde jako samostatny objekt
- global_defs.h , CHKERR a spol. by mely abortovat pri nesplnene podmince ??, DBGPRINT_INT by mela byt spis funkce. 
  ASSERT ... objektovy pristup pomoci streamu, potrebujeme vlstni vystupni stream misto xprintf.
	
4) zjednodusit struct problem - oddelit, 
   !! pokud nejaka funkce pristupuje primo ke strukture problem, je nejspis neco spatne !!

-----------------------

- water_linsys - cleanup, promyslet rozdeleni kodu, komentare ...
- vetsi testovaci ulohy, testovat ruzne parametry petsc i gm6 (doc?)
- jsou schurovy doplnky posdef? Proc ma ICC nulovy pivot a ILU ne?


PROBLEMY:
--------
- ngh vypisuje nesmyslne mnozstvi vygenerovanych sides & edges
- je pomalej pri hledani  VV sousedu (porovnava kazdy s kazdym)
- v element_to_material &
  v element_parse_line
  ... sid se inicializuje ve tretim tagu (negenerovanem starsi verzi GMSH) ale
  v novem GMSH je ve treti tagu partition a sid by bylo az ve ctvrtem tagu

- pri aplikaci BC v rutine boundary_compute_mh, by se melo osertit:
  1) pokud na prislusne edge dochazi take ke komunikaci ,je treba 
     prislusne f_val pricitat
  2) pokud je jde o dirichletovskou podminku je treba zarucit vynulovani 
     prislusneho radku

- ?? Jak se zapocitava gravitace?
- okrajove podminky se zadavaji pouze na elementech (nody program nepodporuje v rozporu 
  s dokumentaci), chybi moznost zadat okrajovou podminku na fyzikalni entite (
  tu GMSH samostatne diskretizuje, takze bude obsahovat samostatne elementy, ktere by
  se mely v programu ztotoznit se skutecnymi elementy a na tech by se aplikovala BC )

- je potreba vymyslet obecnejsi koncept MHSystem - LinSys - Solver
  aby solver mel k dispozici strukturalni informace, pokud je bude potrebovat

  

FUNCIONALITA:
------------
- doplnit moznost pricist casovy clen do bloku D

- testovat vykon serioveho petsc oproti gm6 pri schur complementu
- paralelizace bez ParMETISU
- s ParMETISEM
- optimalizace usporadani pro ILU
- SetValues - predelat na makro, ktere v pripade nepritomnosti PETSc
  bude matici plnit do CSR formatu, v tom pripade jsou potreba stare drivery
  !! tohle je trba delat az po paralelizaci, az bude jasne co ta do toho vsechno vnese


Navrh cile:

1) nacteni site, sestaveni struktyry site
2) paralelizace parMetis
3) presun/znovu nacteni site
4) nacteni dat
5) cyklus cas & nelinearita
    - vypocet matice ulozene po elementech a edges, nezavisle
      na usporadani
    - konkretni plneni usporadane matice, resp. first schur, pripadne second schur
      plneni probiha s konkretnim usporadanim tj. pomoci pole ukazatelu na elementy/
      edges
    - solve
    - v pripade schura -> dopocitani celeho reseni 
      ( k tomu je dobre mit ulozeny prilusne matice )
    - TRANSPORT ...
    


STRUKTURA KODU:
--------------
- podobneho charakteru jsou [run] parametry, checkpointy, logovani, ...

- funkce output, dela 2 ruzne veci - jednak "convert_to_pos" a pak normalni 
  vystup - to by se melo oddelit, taky  
- vetsi zapouzdreni, napr. definovat strukturu Element v element.h a pak
  mit v element.c proceduy co na ni pracujou
- oddelit (jak elegantne) vypocetni data od struktury site
  mozna podstruktury ...
- vytvorit typ Vec3 = pole o 3 duoble (jde to vubec)
  a rutiny pro praci s temito vektory, souradnice nodu ulozit jako vektory,
  sjednotit vypocty ...
- predelat ladici system:
- messages.h - neni lepsi psat zpravy rovnou do kodu, zpravy se malo kdy meni, ale
  v kodu aspon hned vidim co se vypisuje; kromne oprav a prekladu me nenapada duvod
  mit nekde zpravy pohromade
- error_messages.h - to same
- checkpoints: v zasade dobra idea, nicmene tiskove rutiny by mely byt
  tam kde se s prislusnymi strukturami pracuje; check pointy jsou dulezite 
  hlavne pro ladeni tady muzou nastat 2 situace:
  vyvojove ladeni - vetsinou potrebuju operativne menit vypisy
  ladeni chyb od uzivatelu - hodi se celkovy vypis pri fatal error
  ale jinak se od uzivatele neda cekat znalost kodu, takze nevi co ma zapinat
  pro autora zase neni problem si program prelozit, takze zapinani chpointu 
  ze vstupu je zbytecne, 
 
- sestavovat matici primo vypoctem, neukladat si to do struktury site
  matici pripadne ulozit a pracovat pak s ni

- preproces a postproces prejmenovat, transport zpruhlednit - oddelit

- alokace poli az pred tim, kdy je chci plnit, tim odpadnou zbytecne inicializace;
  zachoval bych jen inicializace pointeru na NULL 
- udelat prislusne dealokacni rutiny (ty by naopak mely byt hormadne a testovat, jestli
  je pointer NULL - jinak dealokace)
- definovat typy struktur, aby se nemuselo vsude vypisovat struct Element * ...

- ele->k, ele->a jsou vlastnosti materialu, proc se pocitaji a ukladaji pro kazdy element zvlast ?
- !! strukktura material muze obsahovat bud vodivost nebo storativitu, oboji se nacita nejspis z jednoho souboru
  a pak se to prirazuje elementum, prislo by mi logicke, aby vodivost a storativita byly prvky struktury material,
  podobne jako dalsi mnozstvi parametru ...
- v programu chybi test konzistence dimenze tenzoru s dimenzi elementu 
  (pridal jsem to zatim do tvorby vodivostnich tenzoru)
- udelat spravne oddelene hlavickove soubory, udelat hierarchii hlavickovych souboru, aby se nemusely vypisovat
  vsechny pouzite

- predelat topologii: 
  1) zrusit spojaky, pouzivaji se jen pro prochazeni celeho pole, ktere jde stejne
     udelat pres "hashe" nedefinuji dobre usporadani, je treba je udrzovat v 
     souladu s hasi behem paralelizace
  1.1) ve strukturach oddelit sitove (logicke) veci od dat a pomocnych dat (tvorba matice)
  1.2) zachovat propojeni pointry a nezavisle hashe (tim je mozno provadet preusporadani
       a partitioning aniz by se cela topologie musela precislovavat. 
  2) topologie se tvori hierarchicky:
     - ctou se nody,
     - ctou se elementy, tvori se sides, nodum se priradi ukazatele na elementy 
        (elementy by asi meli ukazovat na nody jen pres sides)
        - sides ukazuji na svuj element a nody 
     - tvori se edges, ktere zaroven nahrazuji "kompatibilni" sousednosti, ukazuji na sve sides 
       pripadne na element nizssi dimenze s kterym komunikuji
       edges se tvori na vnitrnich sides a na vnejsich tokovych
       ( no mozna by byo dobre je mit i na dirichletovskych okrajich, a mit v matici explicitni 
         rovnice pro lambdy - aby se dala jednou implementovat prepinaci podminka)
     - nekde tady se ctou take okrajove podminky a propojuji se se sides 
       (ne sides - to je trochu otazka, ale v principu ano kvuli Newton podminkam)
     - tvori se nekompatibilni propojeni ( mezi elementy ) - 
       asi by to melo zustat samostatnou strukturou, ktera by obsahovala
       - sousedici elementy, delku/plochu sousednosti, vypocteny koeficient prutoku (sigma)
         zavisi na materialech obou elementu a mire sousednosti
       otazka je jestli je treba delat samostatny seznam sousednosti
       a jak snadno element zjisti sve sousedni elementy, kdyz bude mit jen seznam ukazatelu
       na sousednosti (no asi nejlip makrem obsahujicim test )
     
     

